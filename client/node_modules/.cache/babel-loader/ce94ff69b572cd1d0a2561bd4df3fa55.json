{"ast":null,"code":"import FFT from \"fft.js\";\n\n/**\n * @typedef {Float32Array | Float64Array | number[]} Buffer One of the supported\n * buffer types. Other numeric array types may not work correctly.\n */\n\n/**\n * A class that can perform autocorrelation on input arrays of a given size.\n *\n * The class holds internal buffers so that no additional allocations are\n * necessary while performing the operation.\n *\n * @template {Buffer} T the buffer type to use. While inputs to the\n * autocorrelation process can be any array-like type, the output buffer\n * (whether provided explicitly or using a fresh buffer) is always of this type.\n */\nexport class Autocorrelator {\n  /** @private @readonly @type {number} */\n  _inputLength;\n  /** @private @type {FFT} */\n  _fft;\n  /** @private @type {(size: number) => T} */\n  _bufferSupplier;\n  /** @private @type {T} */\n  _paddedInputBuffer;\n  /** @private @type {T} */\n  _transformBuffer;\n  /** @private @type {T} */\n  _inverseBuffer;\n\n  /**\n   * A helper method to create an {@link Autocorrelator} using\n   * {@link Float32Array} buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {Autocorrelator<Float32Array>}\n   */\n  static forFloat32Array(inputLength) {\n    return new Autocorrelator(inputLength, length => new Float32Array(length));\n  }\n\n  /**\n   * A helper method to create an {@link Autocorrelator} using\n   * {@link Float64Array} buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {Autocorrelator<Float64Array>}\n   */\n  static forFloat64Array(inputLength) {\n    return new Autocorrelator(inputLength, length => new Float64Array(length));\n  }\n\n  /**\n   * A helper method to create an {@link Autocorrelator} using `number[]`\n   * buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {Autocorrelator<number[]>}\n   */\n  static forNumberArray(inputLength) {\n    return new Autocorrelator(inputLength, length => Array(length));\n  }\n\n  /**\n   * Constructs a new {@link Autocorrelator} able to handle input arrays of the\n   * given length.\n   *\n   * @param inputLength {number} the input array length to support. This\n   * `Autocorrelator` will only support operation on arrays of this length.\n   * @param bufferSupplier {(length: number) => T} the function to use for\n   * creating buffers, accepting the length of the buffer to create and\n   * returning a new buffer of that length. The values of the returned buffer\n   * need not be initialized in any particular way.\n   */\n  constructor(inputLength, bufferSupplier) {\n    if (inputLength < 1) {\n      throw new Error(`Input length must be at least one`);\n    }\n    this._inputLength = inputLength;\n    // We need to double the input length to get correct results, and the FFT\n    // algorithm we use requires a length that's a power of 2\n    this._fft = new FFT(ceilPow2(2 * inputLength));\n    this._bufferSupplier = bufferSupplier;\n    this._paddedInputBuffer = this._bufferSupplier(this._fft.size);\n    this._transformBuffer = this._bufferSupplier(2 * this._fft.size);\n    this._inverseBuffer = this._bufferSupplier(2 * this._fft.size);\n  }\n\n  /**\n   * Returns the supported input length.\n   *\n   * @returns {number} the supported input length\n   */\n  get inputLength() {\n    return this._inputLength;\n  }\n\n  /**\n   * Autocorrelates the given input data.\n   *\n   * @param input {ArrayLike<number>} the input data to autocorrelate\n   * @param output {T} the output buffer into which to write the autocorrelated\n   * data. If not provided, a new buffer will be created.\n   * @returns {T} `output`\n   */\n  autocorrelate(input) {\n    let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._bufferSupplier(input.length);\n    if (input.length !== this._inputLength) {\n      throw new Error(`Input must have length ${this._inputLength} but had length ${input.length}`);\n    }\n    // Step 0: pad the input array with zeros\n    for (let i = 0; i < input.length; i++) {\n      this._paddedInputBuffer[i] = input[i];\n    }\n    for (let i = input.length; i < this._paddedInputBuffer.length; i++) {\n      this._paddedInputBuffer[i] = 0;\n    }\n\n    // Step 1: get the DFT of the input array\n    this._fft.realTransform(this._transformBuffer, this._paddedInputBuffer);\n    // We need to fill in the right half of the array too\n    this._fft.completeSpectrum(this._transformBuffer);\n    // Step 2: multiply each entry by its conjugate\n    const tb = this._transformBuffer;\n    for (let i = 0; i < tb.length; i += 2) {\n      tb[i] = tb[i] * tb[i] + tb[i + 1] * tb[i + 1];\n      tb[i + 1] = 0;\n    }\n    // Step 3: perform the inverse transform\n    this._fft.inverseTransform(this._inverseBuffer, this._transformBuffer);\n\n    // This last result (the inverse transform) contains the autocorrelation\n    // data, which is completely real\n    for (let i = 0; i < input.length; i++) {\n      output[i] = this._inverseBuffer[2 * i];\n    }\n    return output;\n  }\n}\n\n/**\n * Returns an array of all the key maximum positions in the given input array.\n *\n * In McLeod's paper, a key maximum is the highest maximum between a positively\n * sloped zero crossing and a negatively sloped one.\n *\n * TODO: it may be more efficient not to construct a new output array each time,\n * but that would also make the code more complicated (more so than the changes\n * that were needed to remove the other allocations).\n *\n * @param input {ArrayLike<number>}\n * @returns {number[]}\n */\nfunction getKeyMaximumIndices(input) {\n  // The indices of the key maxima\n  /** @type {number[]} */\n  const keyIndices = [];\n  // Whether the last zero crossing found was positively sloped; equivalently,\n  // whether we're looking for a key maximum\n  let lookingForMaximum = false;\n  // The largest local maximum found so far\n  let max = -Infinity;\n  // The index of the largest local maximum so far\n  let maxIndex = -1;\n  for (let i = 1; i < input.length - 1; i++) {\n    if (input[i - 1] <= 0 && input[i] > 0) {\n      // Positively sloped zero crossing\n      lookingForMaximum = true;\n      maxIndex = i;\n      max = input[i];\n    } else if (input[i - 1] > 0 && input[i] <= 0) {\n      // Negatively sloped zero crossing\n      lookingForMaximum = false;\n      if (maxIndex !== -1) {\n        keyIndices.push(maxIndex);\n      }\n    } else if (lookingForMaximum && input[i] > max) {\n      max = input[i];\n      maxIndex = i;\n    }\n  }\n  return keyIndices;\n}\n\n/**\n * Refines the chosen key maximum index chosen from the given data by\n * interpolating a parabola using the key maximum index and its two neighbors\n * and finding the position of that parabola's maximum value.\n *\n * This is described in section 5 of the MPM paper as a way to refine the\n * position of the maximum.\n *\n * @param index {number} the chosen key maximum index. This must be between `1`\n * and `data.length - 2`, inclusive, since it and its two neighbors need to be\n * valid indexes of `data`.\n * @param data {ArrayLike<number>} the input array from which `index` was chosen\n * @returns {[number, number]} a pair consisting of the refined key maximum index and the\n * interpolated value of `data` at that index (the latter of which is used as a\n * measure of clarity)\n */\nfunction refineResultIndex(index, data) {\n  const [x0, x1, x2] = [index - 1, index, index + 1];\n  const [y0, y1, y2] = [data[x0], data[x1], data[x2]];\n\n  // The parabola going through the three data points can be written as\n  // y = y0(x - x1)(x - x2)/(x0 - x1)(x0 - x2)\n  //   + y1(x - x0)(x - x2)/(x1 - x0)(x1 - x2)\n  //   + y2(x - x0)(x - x1)/(x2 - x0)(x2 - x1)\n  // Given the definitions of x0, x1, and x2, we can simplify the denominators:\n  // y = y0(x - x1)(x - x2)/2\n  //   - y1(x - x0)(x - x2)\n  //   + y2(x - x0)(x - x1)/2\n  // We can expand this out and get the coefficients in standard form:\n  // a = y0/2 - y1 + y2/2\n  // b = -(y0/2)(x1 + x2) + y1(x0 + x2) - (y2/2)(x0 + x1)\n  // c = y0x1x2/2 - y1x0x2 + y2x0x1/2\n  // The index of the maximum is -b / 2a (by solving for x where the derivative\n  // is 0).\n\n  const a = y0 / 2 - y1 + y2 / 2;\n  const b = -(y0 / 2) * (x1 + x2) + y1 * (x0 + x2) - y2 / 2 * (x0 + x1);\n  const c = y0 * x1 * x2 / 2 - y1 * x0 * x2 + y2 * x0 * x1 / 2;\n  const xMax = -b / (2 * a);\n  const yMax = a * xMax * xMax + b * xMax + c;\n  return [xMax, yMax];\n}\n\n/**\n * A class that can detect the pitch of a note from a time-domain input array.\n *\n * This class uses the McLeod pitch method (MPM) to detect pitches. MPM is\n * described in the paper 'A Smarter Way to Find Pitch' by Philip McLeod and\n * Geoff Wyvill\n * (http://miracle.otago.ac.nz/tartini/papers/A_Smarter_Way_to_Find_Pitch.pdf).\n *\n * The class holds internal buffers so that a minimal number of additional\n * allocations are necessary while performing the operation.\n *\n * @template {Buffer} T the buffer type to use internally. Inputs to the\n * pitch-detection process can be any numeric array type.\n */\nexport class PitchDetector {\n  /** @private @type {Autocorrelator<T>} */\n  _autocorrelator;\n  /** @private @type {T} */\n  _nsdfBuffer;\n  // TODO: it might be nice if this were configurable\n  /** @private @readonly */\n  _clarityThreshold = 0.9;\n\n  /**\n   * A helper method to create an {@link PitchDetector} using {@link Float32Array} buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {PitchDetector<Float32Array>}\n   */\n  static forFloat32Array(inputLength) {\n    return new PitchDetector(inputLength, length => new Float32Array(length));\n  }\n\n  /**\n   * A helper method to create an {@link PitchDetector} using {@link Float64Array} buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {PitchDetector<Float64Array>}\n   */\n  static forFloat64Array(inputLength) {\n    return new PitchDetector(inputLength, length => new Float64Array(length));\n  }\n\n  /**\n   * A helper method to create an {@link PitchDetector} using `number[]` buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {PitchDetector<number[]>}\n   */\n  static forNumberArray(inputLength) {\n    return new PitchDetector(inputLength, length => Array(length));\n  }\n\n  /**\n   * Constructs a new {@link PitchDetector} able to handle input arrays of the\n   * given length.\n   *\n   * @param inputLength {number} the input array length to support. This\n   * `PitchDetector` will only support operation on arrays of this length.\n   * @param bufferSupplier {(inputLength: number) => T} the function to use for\n   * creating buffers, accepting the length of the buffer to create and\n   * returning a new buffer of that length. The values of the returned buffer\n   * need not be initialized in any particular way.\n   */\n  constructor(inputLength, bufferSupplier) {\n    this._autocorrelator = new Autocorrelator(inputLength, bufferSupplier);\n    this._nsdfBuffer = bufferSupplier(inputLength);\n  }\n\n  /**\n   * Returns the supported input length.\n   *\n   * @returns {number} the supported input length\n   */\n  get inputLength() {\n    return this._autocorrelator.inputLength;\n  }\n\n  /**\n   * Returns the pitch detected using McLeod Pitch Method (MPM) along with a\n   * measure of its clarity.\n   *\n   * The clarity is a value between 0 and 1 (potentially inclusive) that\n   * represents how \"clear\" the pitch was. A clarity value of 1 indicates that\n   * the pitch was very distinct, while lower clarity values indicate less\n   * definite pitches.\n   *\n   * @param input {ArrayLike<number>} the time-domain input data\n   * @param sampleRate {number} the sample rate at which the input data was\n   * collected\n   * @returns {[number, number]} the detected pitch, in Hz, followed by the clarity\n   */\n  findPitch(input, sampleRate) {\n    this._nsdf(input);\n    const keyMaximumIndices = getKeyMaximumIndices(this._nsdfBuffer);\n    if (keyMaximumIndices.length === 0) {\n      // No key maxima means that we either don't have enough data to analyze or\n      // that the data was flawed (such as an input array of zeroes)\n      return [0, 0];\n    }\n    // The highest key maximum\n    const nMax = Math.max(...keyMaximumIndices.map(i => this._nsdfBuffer[i]));\n    // Following the paper, we return the pitch corresponding to the first key\n    // maximum higher than K * nMax. This is guaranteed not to be undefined, since\n    // we know of at least one key maximum satisfying this condition (whichever\n    // key maximum gave us nMax).\n    const resultIndex = keyMaximumIndices.find(i => this._nsdfBuffer[i] >= this._clarityThreshold * nMax);\n    const [refinedResultIndex, clarity] = refineResultIndex(\n    // @ts-expect-error resultIndex is guaranteed to be defined\n    resultIndex, this._nsdfBuffer);\n\n    // Due to floating point errors, the clarity may occasionally come out to be\n    // slightly over 1.0. We can avoid incorrect results by clamping the value.\n    return [sampleRate / refinedResultIndex, Math.min(clarity, 1.0)];\n  }\n\n  /**\n   * Computes the NSDF of the input and stores it in the internal buffer. This\n   * is equation (9) in the McLeod pitch method paper.\n   *\n   * @private\n   * @param input {ArrayLike<number>}\n   */\n  _nsdf(input) {\n    // The function r'(tau) is the autocorrelation\n    this._autocorrelator.autocorrelate(input, this._nsdfBuffer);\n    // The function m'(tau) (defined in equation (6)) can be computed starting\n    // with m'(0), which is equal to 2r'(0), and then iteratively modified to\n    // get m'(1), m'(2), etc. For example, to get m'(1), we take m'(0) and\n    // subtract x_0^2 and x_{W-1}^2. Then, to get m'(2), we take m'(1) and\n    // subtract x_1^2 and x_{W-2}^2, and further values are similar (see the\n    // note at the end of section 6 in the MPM paper).\n    //\n    // The resulting array values are 2 * r'(tau) / m'(tau). We use m below as\n    // the incremental value of m'.\n    let m = 2 * this._nsdfBuffer[0];\n    /** @type {number} */\n    let i;\n    // As pointed out by issuefiler on GitHub, we can take advantage of the fact\n    // that m will never increase to avoid division by zero by ending this loop\n    // once m === 0. The rest of the array values after m becomes 0 will just be\n    // set to 0 themselves. We actually check for m > 0 rather than m === 0\n    // because there may be small floating-point errors that cause m to become\n    // negative rather than exactly 0.\n    for (i = 0; i < this._nsdfBuffer.length && m > 0; i++) {\n      this._nsdfBuffer[i] = 2 * this._nsdfBuffer[i] / m;\n      m -= input[i] ** 2 + input[input.length - i - 1] ** 2;\n    }\n    // If there are any array values remaining, it means m === 0 for those\n    // values of tau, so we can just set them to 0\n    for (; i < this._nsdfBuffer.length; i++) {\n      this._nsdfBuffer[i] = 0;\n    }\n  }\n}\n\n/**\n * Rounds up the input to the next power of 2.\n *\n * @param {number} v\n * @returns {number} the next power of 2 at least as large as `v`\n */\nfunction ceilPow2(v) {\n  // https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\n  v--;\n  v |= v >> 1;\n  v |= v >> 2;\n  v |= v >> 4;\n  v |= v >> 8;\n  v |= v >> 16;\n  v++;\n  return v;\n}","map":{"version":3,"names":["FFT","Autocorrelator","_inputLength","_fft","_bufferSupplier","_paddedInputBuffer","_transformBuffer","_inverseBuffer","forFloat32Array","inputLength","length","Float32Array","forFloat64Array","Float64Array","forNumberArray","Array","constructor","bufferSupplier","Error","ceilPow2","size","autocorrelate","input","output","i","realTransform","completeSpectrum","tb","inverseTransform","getKeyMaximumIndices","keyIndices","lookingForMaximum","max","Infinity","maxIndex","push","refineResultIndex","index","data","x0","x1","x2","y0","y1","y2","a","b","c","xMax","yMax","PitchDetector","_autocorrelator","_nsdfBuffer","_clarityThreshold","findPitch","sampleRate","_nsdf","keyMaximumIndices","nMax","Math","map","resultIndex","find","refinedResultIndex","clarity","min","m","v"],"sources":["/home/zhadyra/qazaq_aspap/client/node_modules/pitchy/index.js"],"sourcesContent":["import FFT from \"fft.js\";\n\n/**\n * @typedef {Float32Array | Float64Array | number[]} Buffer One of the supported\n * buffer types. Other numeric array types may not work correctly.\n */\n\n/**\n * A class that can perform autocorrelation on input arrays of a given size.\n *\n * The class holds internal buffers so that no additional allocations are\n * necessary while performing the operation.\n *\n * @template {Buffer} T the buffer type to use. While inputs to the\n * autocorrelation process can be any array-like type, the output buffer\n * (whether provided explicitly or using a fresh buffer) is always of this type.\n */\nexport class Autocorrelator {\n  /** @private @readonly @type {number} */\n  _inputLength;\n  /** @private @type {FFT} */\n  _fft;\n  /** @private @type {(size: number) => T} */\n  _bufferSupplier;\n  /** @private @type {T} */\n  _paddedInputBuffer;\n  /** @private @type {T} */\n  _transformBuffer;\n  /** @private @type {T} */\n  _inverseBuffer;\n\n  /**\n   * A helper method to create an {@link Autocorrelator} using\n   * {@link Float32Array} buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {Autocorrelator<Float32Array>}\n   */\n  static forFloat32Array(inputLength) {\n    return new Autocorrelator(\n      inputLength,\n      (length) => new Float32Array(length)\n    );\n  }\n\n  /**\n   * A helper method to create an {@link Autocorrelator} using\n   * {@link Float64Array} buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {Autocorrelator<Float64Array>}\n   */\n  static forFloat64Array(inputLength) {\n    return new Autocorrelator(\n      inputLength,\n      (length) => new Float64Array(length)\n    );\n  }\n\n  /**\n   * A helper method to create an {@link Autocorrelator} using `number[]`\n   * buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {Autocorrelator<number[]>}\n   */\n  static forNumberArray(inputLength) {\n    return new Autocorrelator(inputLength, (length) => Array(length));\n  }\n\n  /**\n   * Constructs a new {@link Autocorrelator} able to handle input arrays of the\n   * given length.\n   *\n   * @param inputLength {number} the input array length to support. This\n   * `Autocorrelator` will only support operation on arrays of this length.\n   * @param bufferSupplier {(length: number) => T} the function to use for\n   * creating buffers, accepting the length of the buffer to create and\n   * returning a new buffer of that length. The values of the returned buffer\n   * need not be initialized in any particular way.\n   */\n  constructor(inputLength, bufferSupplier) {\n    if (inputLength < 1) {\n      throw new Error(`Input length must be at least one`);\n    }\n    this._inputLength = inputLength;\n    // We need to double the input length to get correct results, and the FFT\n    // algorithm we use requires a length that's a power of 2\n    this._fft = new FFT(ceilPow2(2 * inputLength));\n    this._bufferSupplier = bufferSupplier;\n    this._paddedInputBuffer = this._bufferSupplier(this._fft.size);\n    this._transformBuffer = this._bufferSupplier(2 * this._fft.size);\n    this._inverseBuffer = this._bufferSupplier(2 * this._fft.size);\n  }\n\n  /**\n   * Returns the supported input length.\n   *\n   * @returns {number} the supported input length\n   */\n  get inputLength() {\n    return this._inputLength;\n  }\n\n  /**\n   * Autocorrelates the given input data.\n   *\n   * @param input {ArrayLike<number>} the input data to autocorrelate\n   * @param output {T} the output buffer into which to write the autocorrelated\n   * data. If not provided, a new buffer will be created.\n   * @returns {T} `output`\n   */\n  autocorrelate(input, output = this._bufferSupplier(input.length)) {\n    if (input.length !== this._inputLength) {\n      throw new Error(\n        `Input must have length ${this._inputLength} but had length ${input.length}`\n      );\n    }\n    // Step 0: pad the input array with zeros\n    for (let i = 0; i < input.length; i++) {\n      this._paddedInputBuffer[i] = input[i];\n    }\n    for (let i = input.length; i < this._paddedInputBuffer.length; i++) {\n      this._paddedInputBuffer[i] = 0;\n    }\n\n    // Step 1: get the DFT of the input array\n    this._fft.realTransform(this._transformBuffer, this._paddedInputBuffer);\n    // We need to fill in the right half of the array too\n    this._fft.completeSpectrum(this._transformBuffer);\n    // Step 2: multiply each entry by its conjugate\n    const tb = this._transformBuffer;\n    for (let i = 0; i < tb.length; i += 2) {\n      tb[i] = tb[i] * tb[i] + tb[i + 1] * tb[i + 1];\n      tb[i + 1] = 0;\n    }\n    // Step 3: perform the inverse transform\n    this._fft.inverseTransform(this._inverseBuffer, this._transformBuffer);\n\n    // This last result (the inverse transform) contains the autocorrelation\n    // data, which is completely real\n    for (let i = 0; i < input.length; i++) {\n      output[i] = this._inverseBuffer[2 * i];\n    }\n    return output;\n  }\n}\n\n/**\n * Returns an array of all the key maximum positions in the given input array.\n *\n * In McLeod's paper, a key maximum is the highest maximum between a positively\n * sloped zero crossing and a negatively sloped one.\n *\n * TODO: it may be more efficient not to construct a new output array each time,\n * but that would also make the code more complicated (more so than the changes\n * that were needed to remove the other allocations).\n *\n * @param input {ArrayLike<number>}\n * @returns {number[]}\n */\nfunction getKeyMaximumIndices(input) {\n  // The indices of the key maxima\n  /** @type {number[]} */ const keyIndices = [];\n  // Whether the last zero crossing found was positively sloped; equivalently,\n  // whether we're looking for a key maximum\n  let lookingForMaximum = false;\n  // The largest local maximum found so far\n  let max = -Infinity;\n  // The index of the largest local maximum so far\n  let maxIndex = -1;\n\n  for (let i = 1; i < input.length - 1; i++) {\n    if (input[i - 1] <= 0 && input[i] > 0) {\n      // Positively sloped zero crossing\n      lookingForMaximum = true;\n      maxIndex = i;\n      max = input[i];\n    } else if (input[i - 1] > 0 && input[i] <= 0) {\n      // Negatively sloped zero crossing\n      lookingForMaximum = false;\n      if (maxIndex !== -1) {\n        keyIndices.push(maxIndex);\n      }\n    } else if (lookingForMaximum && input[i] > max) {\n      max = input[i];\n      maxIndex = i;\n    }\n  }\n\n  return keyIndices;\n}\n\n/**\n * Refines the chosen key maximum index chosen from the given data by\n * interpolating a parabola using the key maximum index and its two neighbors\n * and finding the position of that parabola's maximum value.\n *\n * This is described in section 5 of the MPM paper as a way to refine the\n * position of the maximum.\n *\n * @param index {number} the chosen key maximum index. This must be between `1`\n * and `data.length - 2`, inclusive, since it and its two neighbors need to be\n * valid indexes of `data`.\n * @param data {ArrayLike<number>} the input array from which `index` was chosen\n * @returns {[number, number]} a pair consisting of the refined key maximum index and the\n * interpolated value of `data` at that index (the latter of which is used as a\n * measure of clarity)\n */\nfunction refineResultIndex(index, data) {\n  const [x0, x1, x2] = [index - 1, index, index + 1];\n  const [y0, y1, y2] = [data[x0], data[x1], data[x2]];\n\n  // The parabola going through the three data points can be written as\n  // y = y0(x - x1)(x - x2)/(x0 - x1)(x0 - x2)\n  //   + y1(x - x0)(x - x2)/(x1 - x0)(x1 - x2)\n  //   + y2(x - x0)(x - x1)/(x2 - x0)(x2 - x1)\n  // Given the definitions of x0, x1, and x2, we can simplify the denominators:\n  // y = y0(x - x1)(x - x2)/2\n  //   - y1(x - x0)(x - x2)\n  //   + y2(x - x0)(x - x1)/2\n  // We can expand this out and get the coefficients in standard form:\n  // a = y0/2 - y1 + y2/2\n  // b = -(y0/2)(x1 + x2) + y1(x0 + x2) - (y2/2)(x0 + x1)\n  // c = y0x1x2/2 - y1x0x2 + y2x0x1/2\n  // The index of the maximum is -b / 2a (by solving for x where the derivative\n  // is 0).\n\n  const a = y0 / 2 - y1 + y2 / 2;\n  const b = -(y0 / 2) * (x1 + x2) + y1 * (x0 + x2) - (y2 / 2) * (x0 + x1);\n  const c = (y0 * x1 * x2) / 2 - y1 * x0 * x2 + (y2 * x0 * x1) / 2;\n\n  const xMax = -b / (2 * a);\n  const yMax = a * xMax * xMax + b * xMax + c;\n  return [xMax, yMax];\n}\n\n/**\n * A class that can detect the pitch of a note from a time-domain input array.\n *\n * This class uses the McLeod pitch method (MPM) to detect pitches. MPM is\n * described in the paper 'A Smarter Way to Find Pitch' by Philip McLeod and\n * Geoff Wyvill\n * (http://miracle.otago.ac.nz/tartini/papers/A_Smarter_Way_to_Find_Pitch.pdf).\n *\n * The class holds internal buffers so that a minimal number of additional\n * allocations are necessary while performing the operation.\n *\n * @template {Buffer} T the buffer type to use internally. Inputs to the\n * pitch-detection process can be any numeric array type.\n */\nexport class PitchDetector {\n  /** @private @type {Autocorrelator<T>} */\n  _autocorrelator;\n  /** @private @type {T} */\n  _nsdfBuffer;\n  // TODO: it might be nice if this were configurable\n  /** @private @readonly */\n  _clarityThreshold = 0.9;\n\n  /**\n   * A helper method to create an {@link PitchDetector} using {@link Float32Array} buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {PitchDetector<Float32Array>}\n   */\n  static forFloat32Array(inputLength) {\n    return new PitchDetector(inputLength, (length) => new Float32Array(length));\n  }\n\n  /**\n   * A helper method to create an {@link PitchDetector} using {@link Float64Array} buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {PitchDetector<Float64Array>}\n   */\n  static forFloat64Array(inputLength) {\n    return new PitchDetector(inputLength, (length) => new Float64Array(length));\n  }\n\n  /**\n   * A helper method to create an {@link PitchDetector} using `number[]` buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {PitchDetector<number[]>}\n   */\n  static forNumberArray(inputLength) {\n    return new PitchDetector(inputLength, (length) => Array(length));\n  }\n\n  /**\n   * Constructs a new {@link PitchDetector} able to handle input arrays of the\n   * given length.\n   *\n   * @param inputLength {number} the input array length to support. This\n   * `PitchDetector` will only support operation on arrays of this length.\n   * @param bufferSupplier {(inputLength: number) => T} the function to use for\n   * creating buffers, accepting the length of the buffer to create and\n   * returning a new buffer of that length. The values of the returned buffer\n   * need not be initialized in any particular way.\n   */\n  constructor(inputLength, bufferSupplier) {\n    this._autocorrelator = new Autocorrelator(inputLength, bufferSupplier);\n    this._nsdfBuffer = bufferSupplier(inputLength);\n  }\n\n  /**\n   * Returns the supported input length.\n   *\n   * @returns {number} the supported input length\n   */\n  get inputLength() {\n    return this._autocorrelator.inputLength;\n  }\n\n  /**\n   * Returns the pitch detected using McLeod Pitch Method (MPM) along with a\n   * measure of its clarity.\n   *\n   * The clarity is a value between 0 and 1 (potentially inclusive) that\n   * represents how \"clear\" the pitch was. A clarity value of 1 indicates that\n   * the pitch was very distinct, while lower clarity values indicate less\n   * definite pitches.\n   *\n   * @param input {ArrayLike<number>} the time-domain input data\n   * @param sampleRate {number} the sample rate at which the input data was\n   * collected\n   * @returns {[number, number]} the detected pitch, in Hz, followed by the clarity\n   */\n  findPitch(input, sampleRate) {\n    this._nsdf(input);\n    const keyMaximumIndices = getKeyMaximumIndices(this._nsdfBuffer);\n    if (keyMaximumIndices.length === 0) {\n      // No key maxima means that we either don't have enough data to analyze or\n      // that the data was flawed (such as an input array of zeroes)\n      return [0, 0];\n    }\n    // The highest key maximum\n    const nMax = Math.max(...keyMaximumIndices.map((i) => this._nsdfBuffer[i]));\n    // Following the paper, we return the pitch corresponding to the first key\n    // maximum higher than K * nMax. This is guaranteed not to be undefined, since\n    // we know of at least one key maximum satisfying this condition (whichever\n    // key maximum gave us nMax).\n    const resultIndex = keyMaximumIndices.find(\n      (i) => this._nsdfBuffer[i] >= this._clarityThreshold * nMax\n    );\n    const [refinedResultIndex, clarity] = refineResultIndex(\n      // @ts-expect-error resultIndex is guaranteed to be defined\n      resultIndex,\n      this._nsdfBuffer\n    );\n\n    // Due to floating point errors, the clarity may occasionally come out to be\n    // slightly over 1.0. We can avoid incorrect results by clamping the value.\n    return [sampleRate / refinedResultIndex, Math.min(clarity, 1.0)];\n  }\n\n  /**\n   * Computes the NSDF of the input and stores it in the internal buffer. This\n   * is equation (9) in the McLeod pitch method paper.\n   *\n   * @private\n   * @param input {ArrayLike<number>}\n   */\n  _nsdf(input) {\n    // The function r'(tau) is the autocorrelation\n    this._autocorrelator.autocorrelate(input, this._nsdfBuffer);\n    // The function m'(tau) (defined in equation (6)) can be computed starting\n    // with m'(0), which is equal to 2r'(0), and then iteratively modified to\n    // get m'(1), m'(2), etc. For example, to get m'(1), we take m'(0) and\n    // subtract x_0^2 and x_{W-1}^2. Then, to get m'(2), we take m'(1) and\n    // subtract x_1^2 and x_{W-2}^2, and further values are similar (see the\n    // note at the end of section 6 in the MPM paper).\n    //\n    // The resulting array values are 2 * r'(tau) / m'(tau). We use m below as\n    // the incremental value of m'.\n    let m = 2 * this._nsdfBuffer[0];\n    /** @type {number} */ let i;\n    // As pointed out by issuefiler on GitHub, we can take advantage of the fact\n    // that m will never increase to avoid division by zero by ending this loop\n    // once m === 0. The rest of the array values after m becomes 0 will just be\n    // set to 0 themselves. We actually check for m > 0 rather than m === 0\n    // because there may be small floating-point errors that cause m to become\n    // negative rather than exactly 0.\n    for (i = 0; i < this._nsdfBuffer.length && m > 0; i++) {\n      this._nsdfBuffer[i] = (2 * this._nsdfBuffer[i]) / m;\n      m -= input[i] ** 2 + input[input.length - i - 1] ** 2;\n    }\n    // If there are any array values remaining, it means m === 0 for those\n    // values of tau, so we can just set them to 0\n    for (; i < this._nsdfBuffer.length; i++) {\n      this._nsdfBuffer[i] = 0;\n    }\n  }\n}\n\n/**\n * Rounds up the input to the next power of 2.\n *\n * @param {number} v\n * @returns {number} the next power of 2 at least as large as `v`\n */\nfunction ceilPow2(v) {\n  // https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\n  v--;\n  v |= v >> 1;\n  v |= v >> 2;\n  v |= v >> 4;\n  v |= v >> 8;\n  v |= v >> 16;\n  v++;\n  return v;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}